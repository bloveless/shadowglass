package main

import (
	"fmt"

	"github.com/gobeam/stringy"
	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateClientFile(gen, f)
			generateHostFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _wasm_client.pb.go file containing gRPC service definitions for use in
// go wasm client modules.
func generateClientFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_client_wasm.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-wasm. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	fmtImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "fmt",
	})
	unsafeImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "unsafe",
	})
	protoImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "google.golang.org/protobuf/proto",
	})

	for _, s := range file.Services {
		for _, m := range s.Methods {
			snakeName := stringy.New(m.GoName).SnakeCase().ToLower()
			g.P(fmt.Sprintf("//go:wasmimport env send_%s_request_to_host", snakeName))
			g.P(fmt.Sprintf("func send%sRequestToHost(ptr uint32, len uint32) uint32", m.GoName))
			g.P()
			g.P(fmt.Sprintf("//go:wasmimport env retrieve_%s_response_from_host", snakeName))
			g.P(fmt.Sprintf("func retrieve%sResponseFromHost(ptr uint32)", m.GoName))
			g.P()
			g.P(fmt.Sprintf("func %s(req %s) (%s ,error) {", m.GoName, m.Input.Desc.Name(), m.Output.Desc.Name()))
			g.P("reqBuffer, err := proto.Marshal(&req)")
			g.P("if err != nil {")
			g.P(fmt.Sprintf(`return %s{}, fmt.Errorf("unable to marshal request: %%w", err)`, m.Output.Desc.Name()))
			g.P("}")
			g.P()
			g.P("ptr := uint32(0)")
			g.P("if len(reqBuffer) > 0 {")
			g.P("ptr = uint32(uintptr(unsafe.Pointer(&reqBuffer[0])))")
			g.P("}")
			g.P()
			g.P(fmt.Sprintf("size := send%sRequestToHost(ptr, uint32(len(reqBuffer)))", m.GoName))
			g.P(fmt.Sprintf("resBuffer := make([]byte, size)"))
			g.P(fmt.Sprintf("retrieve%sResponseFromHost(uint32(uintptr(%sPointer(&resBuffer[0]))))", m.GoName, unsafeImport))
			g.P()
			g.P(fmt.Sprintf("var res %s", m.Output.Desc.Name()))
			g.P()
			g.P(fmt.Sprintf("err = %sUnmarshal(resBuffer, &res)", protoImport))
			g.P("if err != nil {")
			g.P(fmt.Sprintf(`return %s{}, %sErrorf("unable to parse response from memory: %%w", err)`, m.Output.Desc.Name(), fmtImport))
			g.P("}")
			g.P()
			g.P("return res, nil")
			g.P("}")
		}
	}

	return g
}

func generateHostFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_host.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-wasm. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	contextImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "context",
	})
	syncImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "sync",
	})
	wazeroImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "github.com/tetratelabs/wazero",
	})
	wazeroApiImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "github.com/tetratelabs/wazero/api",
	})
	protoImport := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "google.golang.org/protobuf/proto",
	})
	g.P()
	g.P()
	g.P("type Logic interface {")
	for _, s := range file.Services {
		for _, m := range s.Methods {
			g.P(fmt.Sprintf("%s(request *%s) %s", m.GoName, m.Input.Desc.Name(), m.Output.Desc.Name()))
		}
	}
	g.P("}")
	g.P()
	g.P("type staging struct {")
	g.P(fmt.Sprintf("lock %sMutex", syncImport))
	g.P("requestStaging map[string][]byte")
	g.P("}")
	g.P()
	g.P("func newStaging() staging {")
	g.P("return staging{")
	g.P(fmt.Sprintf("lock: %sMutex{},", syncImport))
	g.P("requestStaging: make(map[string][]byte),")
	g.P("}")
	g.P("}")
	g.P()
	g.P("func (s *staging) set(name string, value []byte) {")
	g.P("s.lock.Lock()")
	g.P("defer s.lock.Unlock()")
	g.P()
	g.P("s.requestStaging[name] = value")
	g.P("}")
	g.P()
	g.P("func (s *staging) get(name string) []byte {")
	g.P("s.lock.Lock()")
	g.P("defer s.lock.Unlock()")
	g.P()
	g.P("return s.requestStaging[name]")
	g.P("}")
	g.P()
	for _, s := range file.Services {
		for _, m := range s.Methods {
			snakeName := stringy.New(m.GoName).SnakeCase().ToLower()

			g.P(fmt.Sprintf("func AttachHostFunctions(ctx %sContext, runtime %sRuntime, logic Logic) error {", contextImport, wazeroImport))
			g.P("staging := newStaging()")
			g.P(`_, err := runtime.NewHostModuleBuilder("env").`)
			g.P("NewFunctionBuilder().")
			g.P(fmt.Sprintf("WithGoModuleFunction(api.GoModuleFunc(func(ctx %sContext, m api.Module, stack []uint64) {", contextImport))
			g.P(fmt.Sprintf("var req %sRequest", m.GoName))
			g.P("if stack[0] > 0 {")
			g.P("reqPtr := stack[0]")
			g.P("reqLen := stack[1]")
			g.P("reqBytes, ok := m.Memory().Read(uint32(reqPtr), uint32(reqLen))")
			g.P("if ok == false {")
			g.P(`panic("unable to read memory")`)
			g.P("}")
			g.P(fmt.Sprintf("err := %sUnmarshal(reqBytes, &req)", protoImport))
			g.P("if err != nil {")
			g.P("panic(err)")
			g.P("}")
			g.P("}")
			g.P("var err error")
			g.P()
			g.P("ships := logic.GetMyShips(&req)")
			g.P()
			g.P(fmt.Sprintf("shipsBytes, err := %sMarshal(&ships)", protoImport))
			g.P("if err != nil {")
			g.P("panic(err)")
			g.P("}")
			g.P()
			g.P("staging.set(m.Name(), shipsBytes)")
			g.P()
			g.P(fmt.Sprintf("stack[0] = %sEncodeI64(int64(len(shipsBytes)))", wazeroApiImport))
			g.P(fmt.Sprintf("}), []%sValueType{%sValueTypeI32, %sValueTypeI32}, []%sValueType{%sValueTypeI32}).", wazeroApiImport, wazeroApiImport, wazeroApiImport, wazeroApiImport, wazeroApiImport))
			g.P(fmt.Sprintf(`Export("send_%s_request_to_host").`, snakeName))
			g.P("NewFunctionBuilder().")
			g.P(fmt.Sprintf("WithGoModuleFunction(%sGoModuleFunc(func(ctx context.Context, m %sModule, stack []uint64) {", wazeroApiImport, wazeroApiImport))
			g.P("ptr := stack[0]")
			g.P()
			g.P("shipsBytes := staging.get(m.Name())")
			g.P()
			g.P("if ok := m.Memory().Write(uint32(ptr), shipsBytes); !ok {")
			g.P(`panic("Tried to write out of range")`)
			g.P("}")
			g.P(fmt.Sprintf("}), []%sValueType{%sValueTypeI32}, []api.ValueType{}).", wazeroApiImport, wazeroApiImport))
			g.P(fmt.Sprintf(`Export("retrieve_%s_response_from_host").`, snakeName))
			g.P("Instantiate(ctx)")
			g.P()
			g.P("return err")
			g.P("}")
		}
	}

	return g
}
